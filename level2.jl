# Что происходит с глобальной константой PI, о чем предупреждает интерпретатор?
const PI = 3.14159
println(typeof(PI))
#PI = 3.14  # Ошибка: нельзя изменять значение константы

# Что происходит с типами глобальных переменных ниже, какого типа `c` и почему?
a = 1
b = 2.0
c = a + b
println(typeof(c))  # Float64, так как приведение типов в арифметике

# Что теперь произошло с переменной a? Как происходит биндинг имен в Julia?
a = "foo"  # Изменение типа переменной, Julia допускает динамическую типизацию

# Что происходит с глобальной переменной g и почему? Чем ограничен биндинг имен в Julia?
g::Int = 1 # явное объявление типа
#g = "hi"  # Ошибка: нарушение объявленного типа переменной

function greet()
    g = "hello"  # Локальная переменная g в области видимости функции можно написать global чтобы вытянуть глобально
    println(g)

end
greet()

# Чем отличаются присвоение значений новому имени - и мутация значений?
v = [1,2,3]
z = v  # z и v указывают на один и тот же объект
v[1] = 3  # Мутация - изменение содержания указателя
v = "hello"  # Теперь v указывает на новый объект, 
println(z)  # [3,2,3], так как z все еще указывает на изначальный массив

# Написать тип, параметризованный другим типом
struct  Mytype
    value::Any
end

# Функции для двух аргументов
function add(x, y)
    return x + y
end

function add(x::Int, y::Int)
    return x + y + 1
end

println(add(2, 3))  # 6 (используется конкретная версия)
println(add(2.5, 3.5))  # 6.0 (используется обобщенная версия)

# Абстрактный, примитивный и композитный типы
abstract type AbstractType end
primitive type MyPrimitiveType 64 end
struct str <: AbstractType
    name::String
end

# Диспетчеризация с абстрактными типами
function writstr(a::AbstractType)
    println("ABstract") #эта функция никогда не вызовится, потому что невозможно создать переменную такого типа
end

function writstr(d::str)
    println(d.name)
end

d = str("Stri1")
#e = AbstractType()
println(typeof(d))
#writstr(d)  
#e::AbstractType
#println(typeof(AbstractType)) 

#writstr(e::AbstractType) 


println("______________________________")
#обычная
function f1(s)
    println(s)
end

f1("fdf")
# лямбда
println(())
mul = (x, y) -> x * y
println(mul(4, 7))

ty = 3
yt = 5
println((ty, yt) -> (yt^2 + ty^2))# вот тут начинается занимательный вывод
#println(() -> 34)
#переменное количество аргументов
function printing(nums...)
    return println(nums)
end
printing('g','d','d')
# Пример функции с именованными аргументами

function ChNumArg(name; helloing="Hello")
    return "$helloing, $name !"
end
println(ChNumArg("Daniel")) 
println(ChNumArg("Daniel"; helloing="Congratulation"))  


# Функции с переменным кол-вом именованных аргументов
function info(name; kwargs...)
    return "Имя: $name, Доп. информация: $kwargs"
end
println(info("Данила"))  

println(info("Данила", age=23, city="Петербург", status = "студент"))  
#

#Передать кортеж в функцию, которая принимает на вход несколько аргументов.

function add(a, b, c)
    return a + b + c
end

t = (2, 3, 5)
result = add(t...) 
println(result)

#Присвоить кортеж результату функции, которая возвращает несколько аргументов.

function f5(x)
    return x + 2, x + 3 , x + 4
end

cort = f5(4)
println(cort) 

# Использовать splatting - деструктуризацию кортежа в набор аргументов.
p2, p3, p4 = f5(7)
println(p2) 
println(p3) 
println(p4) 

#Перемножить все элементы массива
#- через loop fusion и
mass4 = [1,2,3,4,5]
result_fusion = prod(mass4)  
println(result_fusion) 

#- с помощью reduce

result_reduce = reduce(*, mass4)
println(result_reduce) 

#Написать функцию от одного аргумента и запустить ее по всем элементам массива
#с помощью точки (broadcast)
function f5(x)
    x+3
end
println(f5.(mass4))

#c помощью map
result_map = map(f5, mass4)
println(result_map)  
#c помощью list comprehension

result_listcomp = [x+3 for x in mass4]
println(result_listcomp) 

# оптимизирование, не создают копию массива, легче читаются (наверное), автоматическая векторизация и парраллельное выполнение для всего массива

# Перемножить вектор-строку [1 2 3] на вектор-столбец [10,20,30] и объяснить результат
# имеем матрица 3 на 1 и 1 на 3
row = [1 2 3] # 1 на 3
col = [1,2,3]# 3 на 1

println(row*col) # при пермножении 1 на 3 на 3 на 1 матрица сжимается до 1 на 1 - скалярное произведение
println(col*row) # при перемножении матриц 3 на 1 на 1 на 3 расширияется до 3 на 3

# В одну строку выбрать из массива [1, -2, 2, 3, 4, -5, 0] только четные и положительные числа

mass5 =  [1, -2, 2, 3, 4, -5, 0]
println( [x for x in mass5 if x > 0 && x % 2 == 0])

# Объяснить следующий код обработки массива names - что за number мы в итоге определили?

using Random #
Random.seed!(123)#
names = [rand('A':'Z') * '_' * rand('0':'9') * rand([".csv", ".bin"]) for _ in 1:100]
# ---формируется 100 случайных название файла сsv или bin состоящее и одной латинской заглавной буквы нижнего подчеркивания и цифры
println(names)

same_names = unique(map(y -> split(y, ".")[1], filter(x -> startswith(x, "A"), names)))
# выбирает названия начинающиеся на А и удаляет расширения оставляя A_n
println(same_names)
numbers = parse.(Int, map(x -> split(x, "_")[end], same_names))
println(numbers)

# из оставшегося набора A_n выбираем только цифры (n) конвнртируя в инт
numbers_sorted = sort(numbers)
# сортируем номера по возрастанию
number = findfirst(n -> !(n in numbers), 0:9)
# ищем минимальную отсутствующую цифру
println(number)

# Упростить этот код обработки: не совсем я сно что значит упростить, сделать короче или понятнее
# ну допустим оставим генерацию, наверное можно не сортировать, ну и можно наверное сраху смотреть если первая буква А вытягивать цифру
# то есть удалить букву и _ если А, еще и расширение, легче взять 3 элемент
# если первый элемент А, то берем 3 элемент
numbers1 = unique(parse.(Int, [n[3] for n in names if n[1] == 'A']))
#number1 = findfirst(!in(numbers1), 0:9)
number1 = findfirst(n -> !(n in numbers1), 0:9)

println(number1)

#4. Свой тип данных на общих интерфейсах
#

#=
написать свой тип ленивого массива, каждый элемент которого
вычисляется при взятии индекса (getindex) по формуле (index - 1)^2
=# 
# ленивый - размер которого задается при создании, но в который можно добавлять элементы
#то есть стурктура? для которой нужно реализовать функцию получения значения по индексу
# то есть нужно при инициализации массива элементы заполнялись по формуле
println("______________________________")

struct MyArr
    size::Int
end

Base.getindex(A::MyArr, i::Int) = (i-1)^2

lazyarr = MyArr(10)
for i in 0:9
    println(lazyarr[i])
end

#=
Написать два типа объектов команд, унаследованных от AbstractCommand,
которые применяются к массиву:
`SortCmd()` - сортирует исходный массив
`ChangeAtCmd(i, val)` - меняет элемент на позиции i на значение val
Каждая команда имеет конструктор и реализацию метода apply!
=#

abstract type AbstractCommand end
apply!(cmd::AbstractCommand, target::Vector) = error("Not implemented for type $(typeof(cmd))")

#сортирует 
struct SortCmd <: AbstractCommand end
apply!(::SortCmd, target::Vector) = sort!(target)
# меняет элемент i
struct ChangeAtCmd <: AbstractCommand
    index::Int
    value
end

apply!(cmd::ChangeAtCmd, target::Vector) = target[cmd.index] = cmd.value
arr = [5, 3, 8, 1, 4]
apply!(SortCmd(), arr)
println(arr)  # [1, 3, 4, 5, 8]

# Применяем команду изменения элемента
apply!(ChangeAtCmd(3, 10), arr)
println(arr)  # [1, 3, 10, 5, 8]

#5. Тесты: как проверять функции?
# можно написать программу которая будет подавать на вход стандарнтые, крайние, ошибочные переменные
# и  сравнивать возвращаемое функцией значение с ожидаемым верным значенпием
# если все тесты проходит верно, значит можно сужить о верности работы функции
# сложность состоит в том чтобы написать тесты покрывающие все возможные варианты работы функции

#6. Дебаг: как отладить функцию по шагам?

#7. Профилировщик: как оценить производительность функции?
# можно по времени работы функции через @time 
@time sort(numbers)

# и по выделению памяти через @allocated
@allocated  sort(numbers)
# через Profile тут более полноая информация
using Profile

Profile.clear() # Очистка предыдущих данных
@profile  sort(numbers)
Profile.print() # Печатает профиль выполнения
#=
Оценить производительность функции с помощью макроса @profview,
и добавить в этот репозиторий файл со скриншотом flamechart'а
=#
function generate_data(len)
    vec1 = randn(len)  
   #= vec1 = Any[] # странная инициализация
    for k = 1:len # смысл в цикле генерировать
        r = randn(1,1)
        append!(vec1, r) # вообще не надо
    end
    =#
    vec2 = sort(vec1)
    vec3 = vec2 .^ 3 .- (sum(vec2) / len)
    return vec3
end

@time generate_data(1_000_000);

Profile.clear() # Очистка предыдущих данных
@profile  generate_data(1_000_000);
Profile.print()
@profview generate_data(1_000_000);

#8. Отличия от матлаба: приращение массива и предварительная аллокация?


#=
Написать функцию определения первой разности, которая принимает и возвращает массив
и для каждой точки входного (x) и выходного (y) выходного массива вычисляет:
y[i] = x[i] - x[i-1]
=#

#=
Аналогичная функция, которая отличается тем, что внутри себя не аллоцирует новый массив y,
а принимает его первым аргументом, сам массив аллоцируется до вызова функции
=#


function f6!(x,y)
    n = length(x)
    for i in 2:n
        y[i] = x[i] - x[i-1]
    end
end
x = [1, 3, 6, 10, 15]
y = zeros(length(x))
f6!(x,y)
println(y)
#=
Написать код, который добавляет элементы в конец массива, в начало массива,
в середину массива
=#
# в конец добавляется через push!
#
# в середину через splice!

#===========================================================================================
9. Модули и функции: как оборачивать функции внутрь модуля, как их экспортировать
и пользоваться вне модуля?
=#

module Foo
    export f7  # Экспортируем только эту функцию

    function f7(x)
        return x^2
    end

    function f8(x)
        return x^3
    end
end  # Закрываем модуль

using .Foo  
println(f7(3))  

import .Foo  
println(Foo.f8(3))  #можем обрвтьтся только через .

#===========================================================================================
10. Зависимости, окружение и пакеты
=#

# Что такое environment, как задать его, как его поменять во время работы?
# окружение установленные пакеты определенных версий прописаны в project и manifest
# переключение через activate
# Что такое пакет (package), как добавить новый пакет?
# набор функций и данных и наверное модулей, что-то вроде библиотеки
# Как начать разрабатывать чужой пакет?
# можно скачать репозиторий или добавить через терминал или команду add 

#=
Как создать свой пакет?
(необязательно, эксперименты с PkgTemplates проводим вне этого репозитория)


=#



#===========================================================================================
12. Аргументы запуска Julia
=#

#=
Как задать окружение при запуске?
ну (@v1.11) pkg> activate .
или можно указать в project.toml
=#

#=
Как задать скрипт, который будет выполняться при запуске:
а) из файла .jl - через скрипт .jl в папке startup или через терминал julia __.jl
б) из текста команды? (см. флаг -e) - julia -e 'println("Hello, Julia!")' - прямое выполнение кода написанного в терминале
мы же обычно вызываем терминал julia и в не работаем
=#
